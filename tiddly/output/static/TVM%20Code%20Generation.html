<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.1.23" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="mobile-web-app-capable" content="yes"/>
<meta name="format-detection" content="telephone=no">
<link id="faviconLink" rel="shortcut icon" href="favicon.ico">
<link rel="stylesheet" href="static.css">
<title>TVM Code Generation: ya0guang's notebook — Personality Backup</title>
</head>
<body class="tc-body">

<section class="tc-story-river tc-static-story-river">
<p><div class="tc-tiddler-frame tc-tiddler-view-frame tc-tiddler-exists  tc-tagged-Analysis tc-tagged-Artifact tc-tagged-WASM" data-tags="Analysis Artifact WASM" data-tiddler-title="TVM Code Generation"><div class="tc-tiddler-title"><div class="tc-titlebar"><span class="tc-tiddler-controls"><span class=" tc-reveal"><button aria-label="more" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fmore-tiddler-actions" title="More actions"></button><div class=" tc-reveal" hidden="true"></div></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal"><button aria-label="edit" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fedit" title="Edit this tiddler"></button></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal"><button aria-label="close" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose" title="Close this tiddler"></button></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span></span><span><h2 class="tc-title">TVM Code Generation</h2></span></div><div class="tc-tiddler-info tc-popup-handle tc-reveal" hidden="true"></div></div><div class=" tc-reveal" hidden="true"></div>
<div class=" tc-reveal"><div class="tc-subtitle"><a class="tc-tiddlylink tc-tiddlylink-missing" href=".html"></a>July 23, 2021 at 12:22 pm</div></div><div class=" tc-reveal">
<div class="tc-tags-wrapper"><span class="tc-tag-list-item">
<span class="tc-tag-label tc-btn-invisible" draggable="true" style="background-color:;
fill:rgb(38, 38, 38);
color:rgb(38, 38, 38);">
Analysis
</span>
<span class="tc-drop-down tc-reveal" hidden="true"></span></span><span class="tc-tag-list-item">
<span class="tc-tag-label tc-btn-invisible" draggable="true" style="background-color:;
fill:rgb(38, 38, 38);
color:rgb(38, 38, 38);">
Artifact
</span>
<span class="tc-drop-down tc-reveal" hidden="true"></span></span><span class="tc-tag-list-item">
<span class="tc-tag-label tc-btn-invisible" draggable="true" style="background-color:;
fill:rgb(38, 38, 38);
color:rgb(38, 38, 38);">
WASM
</span>
<span class="tc-drop-down tc-reveal" hidden="true"></span></span></div>
</div>

<div class="tc-tiddler-body tc-reveal"><ul><li><a class="tc-tiddlylink-external" href="https://tvm.apache.org/" rel="noopener noreferrer" target="_blank">Official Website</a></li></ul><h1 class="">WASM Code Generation Debug Note</h1><ul><li><a class="tc-tiddlylink-external" href="https://github.com/ya0guang/tvm-wasm-teaclave/tree/wasm-debug/apps/wasm-standalone-mod" rel="noopener noreferrer" target="_blank">readme</a></li></ul><h1 class="">Analysis</h1><h2 class=""><code>TVM Build</code></h2><div class=" tc-reveal"><p><button class="">Go♂Deeper</button></p></div><div class=" tc-reveal" hidden="true"></div><p>This Python interface checks the validity of the input and invokes <code>codegen.build_module</code></p><h2 class=""><code>codegen.build_module</code></h2><pre class="py hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_module</span><span class="hljs-params">(mod, target)</span>:</span>
    <span class="hljs-string">"""Build IRModule into Module.

    Parameters
    ----------
    mod : tvm.IRModule
        The ir module.

    target : str
        The target module type.

    Returns
    -------
    module : runtime.Module
        The corressponding module.
    """</span>
    target = Target(target) <span class="hljs-keyword">if</span> isinstance(target, str) <span class="hljs-keyword">else</span> target
    <span class="hljs-keyword">return</span> _ffi_api.Build(mod, target)</code></pre><h2 class="">FFI</h2><p><code>ffi</code> is a very mysterious part in TVM. The <code>_ffi_api</code> is:</p><pre class="py hljs"><code><span class="hljs-string">"""FFI APIs for tvm.target"""</span>
<span class="hljs-keyword">import</span> tvm._ffi


tvm._ffi._init_api(<span class="hljs-string">"target"</span>, __name__)</code></pre><p>Then:</p><pre class="py hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_init_api</span><span class="hljs-params">(namespace, target_module_name=None)</span>:</span>
    <span class="hljs-string">"""Initialize api for a given module name

    namespace : str
       The namespace of the source registry

    target_module_name : str
       The target module name if different from namespace
    """</span>
    target_module_name = target_module_name <span class="hljs-keyword">if</span> target_module_name <span class="hljs-keyword">else</span> namespace
    <span class="hljs-keyword">if</span> namespace.startswith(<span class="hljs-string">"tvm."</span>):
        _init_api_prefix(target_module_name, namespace[<span class="hljs-number">4</span>:])
    <span class="hljs-keyword">else</span>:
        _init_api_prefix(target_module_name, namespace)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_init_api_prefix</span><span class="hljs-params">(module_name, prefix)</span>:</span>
    module = sys.modules[module_name]

    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> list_global_func_names():
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name.startswith(prefix):
            <span class="hljs-keyword">continue</span>

        fname = name[len(prefix) + <span class="hljs-number">1</span> :]
        target_module = module

        <span class="hljs-keyword">if</span> fname.find(<span class="hljs-string">"."</span>) != <span class="hljs-number">-1</span>:
            <span class="hljs-keyword">continue</span>
        f = get_global_func(name)
        ff = _get_api(f)
        ff.__name__ = fname
        ff.__doc__ = <span class="hljs-string">"TVM PackedFunc %s. "</span> % fname
        setattr(target_module, ff.__name__, ff)</code></pre><p>It seems the FFI part in TVM will automatically collect all exported FFIs.</p><p>So I then looked at the related module.</p><h2 class=""><code>src/target/codegen.cc</code></h2><p>There is a <code>Build</code> method which is also registered:</p><pre class="cc hljs"><code><span class="hljs-function">runtime::Module <span class="hljs-title">Build</span><span class="hljs-params">(IRModule mod, Target target)</span> </span>{
  <span class="hljs-keyword">if</span> (transform::PassContext::Current()
          -&gt;GetConfig&lt;Bool&gt;(<span class="hljs-string">"tir.disable_assert"</span>, Bool(<span class="hljs-literal">false</span>))
          .value()) {
    mod = tir::transform::SkipAssert()(mod);
  }

  <span class="hljs-comment">// the build function.</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> build_f_name = <span class="hljs-string">"target.build."</span> + target-&gt;kind-&gt;name;
  <span class="hljs-keyword">const</span> PackedFunc* bf = runtime::Registry::Get(build_f_name);
  ICHECK(bf != <span class="hljs-literal">nullptr</span>) &lt;&lt; build_f_name &lt;&lt; <span class="hljs-string">" is not enabled"</span>;
  <span class="hljs-keyword">return</span> (*bf)(mod, target);
}

<span class="hljs-comment">// Some code here</span>

TVM_REGISTER_GLOBAL(<span class="hljs-string">"target.Build"</span>).set_body_typed(Build);</code></pre><p>Here this function calls <code>target.build.llvm</code> indirectly in my case.</p><h2 class=""><code>src/target/llvm/llvm_module.cc</code></h2><p>Just like the previous one, the function has been registered:</p><pre class="cc hljs"><code>TVM_REGISTER_GLOBAL(<span class="hljs-string">"target.build.llvm"</span>)
    .set_body_typed([](IRModule mod, Target target) -&gt; runtime::Module {
      <span class="hljs-keyword">auto</span> n = make_object&lt;LLVMModuleNode&gt;();
      n-&gt;Init(mod, target);
      <span class="hljs-keyword">return</span> runtime::Module(n);
    });</code></pre><p>And this function invokes <code>LLVMModuleNode::Init</code></p><div class=" tc-reveal"><p><button class="">Go♂Deeper</button></p></div><div class=" tc-reveal" hidden="true"></div><p>At the beginning it does some parameter checks. </p><p>The function here invokes <code>CodeGenLLVM::Init</code>, which initializes the code generator for LLVM.</p><p>The core functions for generating functions in LLVM are:</p><pre class="cc hljs"><code>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CodeGenLLVM::AddFunction</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PrimFunc&amp; f)</span> </span>{ <span class="hljs-keyword">this</span>-&gt;AddFunctionInternal(f, <span class="hljs-literal">false</span>); }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CodeGenLLVM::InitFuncState</span><span class="hljs-params">()</span> </span>{
  var_map_.<span class="hljs-built_in">clear</span>();
  alias_var_set_.<span class="hljs-built_in">clear</span>();
  alloc_storage_info_.<span class="hljs-built_in">clear</span>();
  volatile_buf_.<span class="hljs-built_in">clear</span>();
  analyzer_.reset(<span class="hljs-keyword">new</span> arith::Analyzer());
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CodeGenLLVM::AddFunctionInternal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PrimFunc&amp; f, <span class="hljs-keyword">bool</span> ret_void)</span> </span>{
  <span class="hljs-keyword">this</span>-&gt;InitFuncState();

  ICHECK_EQ(f-&gt;buffer_map.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0U</span>)
      &lt;&lt; <span class="hljs-string">"Cannot codegen function with buffer_map, please lower them first"</span>;

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;llvm::Type*&gt; param_types;
  is_restricted_ = f-&gt;HasNonzeroAttr(tir::attr::kNoAlias);
  <span class="hljs-keyword">for</span> (Var param : f-&gt;params) {
    param_types.push_back(GetLLVMType(param));
    <span class="hljs-keyword">if</span> (!is_restricted_ &amp;&amp; param.dtype().is_handle()) {
      alias_var_set_.insert(param.<span class="hljs-built_in">get</span>());
    }
  }
  <span class="hljs-comment">// TODO(tvm-team):</span>
  <span class="hljs-comment">// Update the function type to respect the ret_type field of f.</span>
  <span class="hljs-comment">// Once we allow more flexibility in the PrimFunc.</span>
  llvm::FunctionType* ftype =
      llvm::FunctionType::<span class="hljs-built_in">get</span>(ret_void ? t_void_ : t_int_, param_types, <span class="hljs-literal">false</span>);

  <span class="hljs-keyword">auto</span> global_symbol = f-&gt;GetAttr&lt;<span class="hljs-keyword">String</span>&gt;(tvm::attr::kGlobalSymbol);
  ICHECK(global_symbol.defined())
      &lt;&lt; <span class="hljs-string">"CodeGenLLVM: Expect PrimFunc to have the global_symbol attribute"</span>;
  ICHECK(module_-&gt;getFunction(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(global_symbol.value())) == <span class="hljs-literal">nullptr</span>)
      &lt;&lt; <span class="hljs-string">"Function "</span> &lt;&lt; global_symbol &lt;&lt; <span class="hljs-string">" already exist in module"</span>;

  function_ = llvm::Function::Create(ftype, llvm::Function::ExternalLinkage,
                                     global_symbol.value().<span class="hljs-keyword">operator</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(), module_.<span class="hljs-built_in">get</span>());
  function_-&gt;setCallingConv(llvm::CallingConv::C);
  function_-&gt;setDLLStorageClass(llvm::GlobalValue::DLLStorageClassTypes::DLLExportStorageClass);

  <span class="hljs-comment">// set var map and align information</span>
  <span class="hljs-keyword">auto</span> arg_it = function_-&gt;arg_begin();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; f-&gt;params.<span class="hljs-built_in">size</span>(); ++i, ++arg_it) {
    llvm::Argument* v = &amp;(*arg_it);
    <span class="hljs-keyword">const</span> Var&amp; var = f-&gt;params[i];
    var_map_[var.<span class="hljs-built_in">get</span>()] = v;
    <span class="hljs-keyword">if</span> (is_restricted_) {
      <span class="hljs-keyword">if</span> (var.dtype().is_handle() &amp;&amp; !alias_var_set_.count(var.<span class="hljs-built_in">get</span>())) {
        <span class="hljs-comment">// set non alias.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TVM_LLVM_VERSION &gt;= 50</span>
        function_-&gt;addParamAttr(i, llvm::Attribute::NoAlias);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        function_-&gt;setDoesNotAlias(i + <span class="hljs-number">1</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
      }
    }
  }
  llvm::BasicBlock* entry = llvm::BasicBlock::Create(*ctx_, <span class="hljs-string">"entry"</span>, function_);
  builder_-&gt;SetInsertPoint(entry);
  <span class="hljs-keyword">this</span>-&gt;VisitStmt(f-&gt;body);

  <span class="hljs-comment">// Add alignment attribute if needed.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> TVM_LLVM_VERSION &gt;= 50</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; f-&gt;params.<span class="hljs-built_in">size</span>(); ++i) {
    <span class="hljs-keyword">const</span> Var&amp; var = f-&gt;params[i];
    <span class="hljs-keyword">auto</span> f = alloc_storage_info_.<span class="hljs-built_in">find</span>(var.<span class="hljs-built_in">get</span>());
    <span class="hljs-keyword">if</span> (f != alloc_storage_info_.<span class="hljs-built_in">end</span>()) {
      <span class="hljs-keyword">unsigned</span> align = f-&gt;second.alignment;
      <span class="hljs-keyword">if</span> (align &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">auto</span> attr = llvm::Attribute::<span class="hljs-built_in">get</span>(*ctx_, llvm::Attribute::Alignment, align);
        function_-&gt;addParamAttr(i, attr);
      }
    }
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

  llvm::StringRef fs = target_machine_-&gt;getTargetFeatureString();
  <span class="hljs-keyword">if</span> (!fs.empty()) {
    function_-&gt;addFnAttr(<span class="hljs-string">"target-features"</span>, fs);
  }

  <span class="hljs-keyword">if</span> (ret_void) {
    builder_-&gt;CreateRetVoid();
  } <span class="hljs-keyword">else</span> {
    builder_-&gt;CreateRet(ConstInt32(<span class="hljs-number">0</span>));
  }
}</code></pre><p>However, there is no function that have the same signature as <code>BackendPackedCFunc</code>.</p><h2 class=""><code>Tir</code> Level Transformation</h2><p>After searching for a while, I finally found a place for  <code>BackendPackedCFunc</code> generation. It invoked in the Python script: <code>mod_host, mdev = _build_for_device(input_mod, tar, target_host)</code>:</p><pre class="py hljs"><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_build_for_device</span><span class="hljs-params">(input_mod, target, target_host)</span>:</span>
    <span class="hljs-string">"""Build the lowered functions for a device with the given compilation
    target.

    Parameters
    ----------
    input_mod : IRModule
        The schedule to be built.

    target : str or :any:`tvm.target.Target`
        The target and option of the compilation.

    target_host : str or :any:`tvm.target.Target`
        The host compilation target.

    Returns
    -------
    fhost : IRModule
        The host IRModule.

    mdev : tvm.module
        A module that contains device code.
    """</span>
    target, target_host = Target.check_and_update_host_consist(target, target_host)
    device_type = ndarray.device(target.kind.name, <span class="hljs-number">0</span>).device_type

    mod_mixed = input_mod
    mod_mixed = tvm.tir.transform.Apply(<span class="hljs-keyword">lambda</span> f: f.with_attr(<span class="hljs-string">"target"</span>, target))(mod_mixed)

    opt_mixed = [tvm.tir.transform.VerifyMemory()]
    <span class="hljs-keyword">if</span> len(mod_mixed.functions) == <span class="hljs-number">1</span>:
        opt_mixed += [tvm.tir.transform.Apply(<span class="hljs-keyword">lambda</span> f: f.with_attr(<span class="hljs-string">"tir.is_entry_func"</span>, <span class="hljs-literal">True</span>))]

    <span class="hljs-keyword">if</span> PassContext.current().config.get(<span class="hljs-string">"tir.detect_global_barrier"</span>, <span class="hljs-literal">False</span>):
        opt_mixed += [tvm.tir.transform.ThreadSync(<span class="hljs-string">"global"</span>)]
    opt_mixed += [
        tvm.tir.transform.ThreadSync(<span class="hljs-string">"shared"</span>),
        tvm.tir.transform.ThreadSync(<span class="hljs-string">"warp"</span>),
        tvm.tir.transform.InferFragment(),
        tvm.tir.transform.LowerThreadAllreduce(),
        tvm.tir.transform.MakePackedAPI(),
        tvm.tir.transform.SplitHostDevice(),
    ]
    mod_mixed = tvm.transform.Sequential(opt_mixed)(mod_mixed)

    <span class="hljs-comment"># device optimizations</span>
    opt_device = tvm.transform.Sequential(
        [
            tvm.tir.transform.Filter(
                <span class="hljs-keyword">lambda</span> f: <span class="hljs-string">"calling_conv"</span> <span class="hljs-keyword">in</span> f.attrs
                <span class="hljs-keyword">and</span> f.attrs[<span class="hljs-string">"calling_conv"</span>].value == CallingConv.DEVICE_KERNEL_LAUNCH
            ),
            tvm.tir.transform.LowerWarpMemory(),
            tvm.tir.transform.Simplify(),
            tvm.tir.transform.LowerDeviceStorageAccessInfo(),
            tvm.tir.transform.LowerCustomDatatypes(),
            tvm.tir.transform.LowerIntrin(),
        ]
    )
    mod_dev = opt_device(mod_mixed)

    <span class="hljs-comment"># host optimizations</span>
    opt_host = tvm.transform.Sequential(
        [
            tvm.tir.transform.Filter(
                <span class="hljs-keyword">lambda</span> f: <span class="hljs-string">"calling_conv"</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> f.attrs
                <span class="hljs-keyword">or</span> f.attrs[<span class="hljs-string">"calling_conv"</span>].value != CallingConv.DEVICE_KERNEL_LAUNCH
            ),
            tvm.tir.transform.Apply(<span class="hljs-keyword">lambda</span> f: f.with_attr(<span class="hljs-string">"target"</span>, target_host)),
            tvm.tir.transform.LowerTVMBuiltin(),
            tvm.tir.transform.LowerDeviceStorageAccessInfo(),
            tvm.tir.transform.LowerCustomDatatypes(),
            tvm.tir.transform.LowerIntrin(),
            tvm.tir.transform.CombineContextCall(),
        ]
    )
    mod_host = opt_host(mod_mixed)

    <span class="hljs-keyword">if</span> device_type == ndarray.cpu(<span class="hljs-number">0</span>).device_type <span class="hljs-keyword">and</span> target_host == target:
        <span class="hljs-keyword">assert</span> len(mod_dev.functions) == <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">"gpu"</span> <span class="hljs-keyword">in</span> target.keys <span class="hljs-keyword">and</span> len(mod_dev.functions) == <span class="hljs-number">0</span>:
        warnings.warn(
            <span class="hljs-string">"Specified target %s, but cannot find device code, did you do "</span> <span class="hljs-string">"bind?"</span> % target
        )

    rt_mod_dev = codegen.build_module(mod_dev, target) <span class="hljs-keyword">if</span> len(mod_dev.functions) != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">return</span> mod_host, rt_mod_dev</code></pre><p>Here the function <code>MakePackedAPI</code> generates the function with <code>BackendPackedCFunc</code> signature.</p><pre class="cc hljs"><code><span class="hljs-function">PrimFunc <span class="hljs-title">MakePackedAPI</span><span class="hljs-params">(PrimFunc&amp;&amp; func, <span class="hljs-keyword">int</span> num_unpacked_args)</span> </span>{
  <span class="hljs-keyword">auto</span> global_symbol = func-&gt;GetAttr&lt;<span class="hljs-keyword">String</span>&gt;(tvm::attr::kGlobalSymbol);
  ICHECK(global_symbol) &lt;&lt; <span class="hljs-string">"MakePackedAPI: Expect PrimFunc to have the global_symbol attribute"</span>;

  <span class="hljs-keyword">auto</span> target = func-&gt;GetAttr&lt;Target&gt;(tvm::attr::kTarget);
  ICHECK(target.defined()) &lt;&lt; <span class="hljs-string">"MakePackedAPI: Require the target attribute"</span>;
  <span class="hljs-keyword">int</span> target_device_type = target.value()-&gt;kind-&gt;device_type;

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name_hint = global_symbol.value();

  <span class="hljs-keyword">auto</span>* func_ptr = func.CopyOnWrite();
  <span class="hljs-keyword">const</span> Stmt nop = Evaluate(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">int</span> num_args = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(func_ptr-&gt;params.<span class="hljs-built_in">size</span>());
  ICHECK_LE(num_unpacked_args, num_args);
  <span class="hljs-keyword">bool</span> pack_args = (num_unpacked_args == <span class="hljs-number">-1</span>) || (num_args &gt; num_unpacked_args);
  <span class="hljs-keyword">if</span> (num_unpacked_args == <span class="hljs-number">-1</span>) {
    <span class="hljs-comment">// reset to zero</span>
    num_unpacked_args = <span class="hljs-number">0</span>;
  }
  ICHECK_GE(num_unpacked_args, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">int</span> num_packed_args = num_args - num_unpacked_args;
  <span class="hljs-comment">// Data field definitions</span>
  <span class="hljs-comment">// The packed fields</span>
  <span class="hljs-function">Var <span class="hljs-title">v_packed_args</span><span class="hljs-params">(<span class="hljs-string">"args"</span>, DataType::Handle())</span></span>;
  <span class="hljs-function">Var <span class="hljs-title">v_packed_arg_type_ids</span><span class="hljs-params">(<span class="hljs-string">"arg_type_ids"</span>, DataType::Handle())</span></span>;
  <span class="hljs-function">Var <span class="hljs-title">v_num_packed_args</span><span class="hljs-params">(<span class="hljs-string">"num_args"</span>, DataType::Int(<span class="hljs-number">32</span>))</span></span>;
  <span class="hljs-function">Var <span class="hljs-title">v_out_ret_value</span><span class="hljs-params">(<span class="hljs-string">"out_ret_value"</span>, DataType::Handle())</span></span>;
  <span class="hljs-function">Var <span class="hljs-title">v_out_ret_tcode</span><span class="hljs-params">(<span class="hljs-string">"out_ret_tcode"</span>, DataType::Handle())</span></span>;
  <span class="hljs-function">Var <span class="hljs-title">v_resource_handle</span><span class="hljs-params">(<span class="hljs-string">"resource_handle"</span>, DataType::Handle())</span></span>;
  <span class="hljs-comment">// The arguments of the function.</span>
  Array&lt;Var&gt; args;
  <span class="hljs-comment">// The device context</span>
  <span class="hljs-function">Var <span class="hljs-title">device_id</span><span class="hljs-params">(<span class="hljs-string">"dev_id"</span>)</span></span>;
  <span class="hljs-function">Integer <span class="hljs-title">device_type</span><span class="hljs-params">(target_device_type)</span></span>;
  <span class="hljs-comment">// seq_init gives sequence of initialization</span>
  <span class="hljs-comment">// seq_check gives sequence of later checks after init</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Stmt&gt; seq_init, seq_check;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">const</span> VarNode*, PrimExpr&gt; vmap;
  <span class="hljs-function">ArgBinder <span class="hljs-title">binder</span><span class="hljs-params">(&amp;vmap)</span></span>;
  <span class="hljs-comment">// ---------------------------</span>
  <span class="hljs-comment">// local function definitions</span>
  <span class="hljs-comment">// load i-th argument as type t</span>
  <span class="hljs-keyword">auto</span> f_arg_value = [&amp;](DataType t, <span class="hljs-keyword">int</span> i) {
    Array&lt;PrimExpr&gt; call_args{v_packed_args, IntImm(DataType::Int(<span class="hljs-number">32</span>), i),
                              IntImm(DataType::Int(<span class="hljs-number">32</span>), builtin::kTVMValueContent)};
    <span class="hljs-comment">// load 64 bit version</span>
    DataType api_type = APIType(t);
    PrimExpr res = Call(api_type, builtin::tvm_struct_get(), call_args);
    <span class="hljs-comment">// cast to the target version.</span>
    <span class="hljs-keyword">if</span> (api_type != t) {
      res = Cast(t, res);
    }
    <span class="hljs-keyword">return</span> res;
  };
  <span class="hljs-comment">// ---------------------------</span>
  <span class="hljs-comment">// start of logics</span>
  <span class="hljs-comment">// add signiture for packed arguments.</span>
  <span class="hljs-keyword">if</span> (pack_args) {
    args.push_back(v_packed_args);
    args.push_back(v_packed_arg_type_ids);
    args.push_back(v_num_packed_args);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> os;

    os &lt;&lt; name_hint &lt;&lt; <span class="hljs-string">": num_args should be "</span> &lt;&lt; num_packed_args;
    seq_init.emplace_back(MakeAssertEQ(v_num_packed_args, num_packed_args, os.str()));
  }

  <span class="hljs-comment">// Need to re-declare vars, in case some arguments also appears in the buffer.</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;Var, Var&gt; &gt; var_def;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;Var, Buffer&gt; &gt; buffer_def;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(func_ptr-&gt;params.<span class="hljs-built_in">size</span>()); ++i) {
    Var param = func_ptr-&gt;params[i];
    Var v_arg = Var(<span class="hljs-string">"arg"</span> + <span class="hljs-built_in">std</span>::to_string(i), param-&gt;dtype);

    <span class="hljs-keyword">auto</span> it = func_ptr-&gt;buffer_map.<span class="hljs-built_in">find</span>(param);
    <span class="hljs-keyword">if</span> (it != func_ptr-&gt;buffer_map.<span class="hljs-built_in">end</span>()) {
      buffer_def.emplace_back(v_arg, (*it).second);
    } <span class="hljs-keyword">else</span> {
      var_def.emplace_back(v_arg, param);
    }
    <span class="hljs-keyword">if</span> (i &lt; num_packed_args) {
      <span class="hljs-comment">// Value loads</span>
      seq_init.emplace_back(LetStmt(v_arg, f_arg_value(v_arg.dtype(), i), nop));
      <span class="hljs-comment">// type code checks</span>
      <span class="hljs-function">Var <span class="hljs-title">tcode</span><span class="hljs-params">(v_arg-&gt;name_hint + <span class="hljs-string">".code"</span>, DataType::Int(<span class="hljs-number">32</span>))</span></span>;
      seq_init.emplace_back(LetStmt(tcode,
                                    Load(DataType::Int(<span class="hljs-number">32</span>), v_packed_arg_type_ids,
                                         IntImm(DataType::Int(<span class="hljs-number">32</span>), i), const_true(<span class="hljs-number">1</span>)),
                                    nop));
      DataType t = v_arg.dtype();
      <span class="hljs-keyword">if</span> (t.is_handle()) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> msg;
        msg &lt;&lt; name_hint &lt;&lt; <span class="hljs-string">": Expect arg["</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"] to be pointer"</span>;
        seq_check.emplace_back(AssertStmt(tcode == kTVMOpaqueHandle || tcode == kTVMNDArrayHandle ||
                                              tcode == kTVMDLTensorHandle || tcode == kTVMNullptr,
                                          tvm::tir::StringImm(msg.str()), nop));
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.is_int() || t.is_uint()) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> msg;
        msg &lt;&lt; name_hint &lt;&lt; <span class="hljs-string">": Expect arg["</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"] to be int"</span>;
        seq_check.emplace_back(AssertStmt(tcode == kDLInt, tvm::tir::StringImm(msg.str()), nop));
      } <span class="hljs-keyword">else</span> {
        ICHECK(t.is_float());
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> msg;
        msg &lt;&lt; name_hint &lt;&lt; <span class="hljs-string">": Expect arg["</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"] to be float"</span>;
        seq_check.emplace_back(AssertStmt(tcode == kDLFloat, tvm::tir::StringImm(msg.str()), nop));
      }
    } <span class="hljs-keyword">else</span> {
      args.push_back(v_arg);
    }
  }

  <span class="hljs-comment">// allow return value if the function is packed.</span>
  <span class="hljs-keyword">if</span> (pack_args) {
    args.push_back(v_out_ret_value);
    args.push_back(v_out_ret_tcode);
    args.push_back(v_resource_handle);
  }

  <span class="hljs-keyword">size_t</span> expected_nargs = num_unpacked_args + (pack_args ? <span class="hljs-number">6</span> : <span class="hljs-number">0</span>);
  ICHECK_EQ(args.<span class="hljs-built_in">size</span>(), expected_nargs);

  <span class="hljs-comment">// Arg definitions are defined before buffer binding to avoid the use before</span>
  <span class="hljs-comment">// def errors.</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// For example, for auto broadcasting, checks are required to guarantee that</span>
  <span class="hljs-comment">// either 0 or the original stride will be correctly used. Checks here have</span>
  <span class="hljs-comment">// to use the args that may have no let binding yet. Therefore, hoisting let</span>
  <span class="hljs-comment">// binding for args before buffer declaration is needed.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; kv : var_def) {
    binder.Bind(kv.second, kv.first, kv.first-&gt;name_hint, <span class="hljs-literal">true</span>);
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; kv : buffer_def) {
    binder.BindDLTensor(kv.second, device_type, device_id, kv.first, kv.first-&gt;name_hint);
  }

  <span class="hljs-keyword">if</span> (num_unpacked_args == <span class="hljs-number">0</span>) {
    func = WithAttr(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(func), tvm::attr::kCallingConv, Integer(CallingConv::kCPackedFunc));
  }

  Stmt body = RewriteReturn(func_ptr-&gt;body, v_out_ret_value, v_out_ret_tcode);
  body = AttrStmt(make_zero(DataType::Int(<span class="hljs-number">32</span>)), attr::compute_scope,
                  StringImm(name_hint + <span class="hljs-string">"_compute_"</span>), body);
  <span class="hljs-comment">// Set device context</span>
  <span class="hljs-keyword">if</span> (vmap.count(device_id.<span class="hljs-built_in">get</span>())) {
    PrimExpr node = StringImm(<span class="hljs-string">"default"</span>);
    seq_check.push_back(AttrStmt(node, attr::device_id, device_id, nop));
    seq_check.push_back(AttrStmt(node, attr::device_type, device_type, nop));

    <span class="hljs-keyword">if</span> (runtime::DeviceAPI::NeedSetDevice(target_device_type)) {
      Stmt set_device =
          Evaluate(Call(DataType::Int(<span class="hljs-number">32</span>), builtin::tvm_call_packed(),
                        {StringImm(runtime::symbol::tvm_set_device), device_type, device_id}));
      body = SeqStmt({set_device, body});
    }
  }
  func_ptr-&gt;body = MergeNest({seq_init, binder.init_nest(), seq_check, binder.asserts()}, body);
  func_ptr-&gt;params = args;

  Array&lt;Var&gt; undefined = UndefinedVars(func_ptr-&gt;body, func_ptr-&gt;params);
  <span class="hljs-keyword">if</span> (undefined.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> os;
    <span class="hljs-keyword">for</span> (Var v : undefined) {
      os &lt;&lt; <span class="hljs-string">" \'"</span> &lt;&lt; v-&gt;name_hint &lt;&lt; <span class="hljs-string">"\' "</span>;
    }
    os &lt;&lt; <span class="hljs-string">" is not bound to any variables"</span>;
    LOG(FATAL) &lt;&lt; <span class="hljs-string">"Not all Vars are passed in api_args: "</span> &lt;&lt; os.str();
  }

  func_ptr-&gt;buffer_map = Map&lt;Var, Buffer&gt;();
  func_ptr-&gt;checked_type_ = func_ptr-&gt;func_type_annotation();
  func_ptr-&gt;ret_type = PrimType(DataType::Int(<span class="hljs-number">32</span>));

  <span class="hljs-comment">// return the function.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(func);
}</code></pre></div>

<div class="tc-tiddler-plugin-info tc-reveal"><p>
</p></div>
</div>

</p>
</section>
</body>
</html>

